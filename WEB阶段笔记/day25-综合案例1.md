=======================================回顾和复习
1）Maven
	1）使用Maven创建war工程
			* 引入依赖(引入jar包)
				* 依赖范围
					compile		默认，编译、测试、运行
					provided，	编译、测试
					test，		测试
					runtime，	测试、运行
					system，	本地仓库外的jar包
			* 引入插件
2）案例
	1）需求
	2）搭建本地项目环境
			* 在idea中引入maven工程	==> pom.xml
			* 启动maven的war工程	==> tomcat7插件，执行命令：tomcat7:run
			* 数据库环境
	3）用户注册
			1）前台
				* 表单校验	==> JS
						submit事件	：在所有校验都通过的情况下，异步发送请求，并且携带表单数据，即表单数据的异步提交，表单的submit事件对应的函数的返回值永远是false。
						blur事件
				* 异步提交表单数据
						$.post()
						$("#form").serialize()
			2）后台
				servlet:
					1、获取请求参数
					2、调用service进行业务处理，返回有一个结果
					3、将结果异步响应给浏览器
				service:
					1、提供一个方法，参数是User对象，返回值是boolean
							根据用户名，查询数据库，返回一个User对象
									not null：说明用户名已经被占用，返回false
									null：说明用户名可以使用，可以进行账号注册，需要：
												1）设置一个激活码属性
												2）设置用户的激活状态为N
												3）保存用户
												4）发送激活邮件
												5）返回true
				dao:
					1、提供两个方法
							* 根据用户名查询用户，返回User对象
							* 保存用户数据
			3）邮件激活
				目的：为了保证邮箱的有效，为了防止恶意注册，为了后期发送一些宣传邮件
				步骤：
					1）发送激活邮件
							* 在用户信息保存在数据库之后，也就是在service方法最后
							* MailUtils工具类
									sendMail()  参数
									props.put("mail.smtp.host", "smtp.qq.com");	使用qq邮箱
							* 邮件中包含：
									用户信息(code,激活码)
									提供一个可点击的链接：指向黑马旅游网的服务器
							* 在保存用户信息的时候，还需要：
									保存一个激活码(code)
									保存用户的激活状态为N
					2）点击邮件的激活连接，激活账号
							* 实质：将用户的状态从N改为Y，根据激活码(code)

					扩展(几个概念)：
						邮箱服务器：安装了邮箱服务器软件的电脑	
						电子邮箱：在邮箱服务器上的一块空间，这块空间是私有的，有账号有密码
						电子邮件：电子邮箱中的一条一条记录，每一条记录就成为一封邮件
						收发邮件的协议：
							发邮件：简单邮件传输协议 (Simple Mail Transfer Protocol, SMTP) 是在Internet传输email的事实标准。默认端口：25
							收邮件：POP3，全名为“Post Office Protocol - Version 3”，即“邮局协议版本3”。是TCP/IP协议族中的一员，本协议主要用于支持使用客户端远程管理在服务器上的电子邮件。默认端口：110
									IMAP（Internet Mail Access Protocol，Internet邮件访问协议），它的主要作用是邮件客户端（例如MS Outlook Express)可以通过这种协议从邮件服务器上获取邮件的信息，下载邮件等。默认端口：143
						邮件客户端：
							foxmail：免费的
							outlook：收费的
	4）用户登录
		1）用户登录
				LoginServlet核心逻辑：
					...
					User u  = service.login(user);
					ResultInfo info = new ResultInfo();
					//4.判断用户对象是否为null
					if(u == null){
						//用户名密码或错误
						info.setFlag(false);
						info.setErrorMsg("用户名密码或错误");
					}else{
						//5.判断用户是否激活
						if("Y".equals(u.getStatus())){
							//登录成功后，将用户信息存储到session中
							request.getSession().setAttribute("user",u);
							//登录成功
							info.setFlag(true);
						}else{
							//用户尚未激活
							info.setFlag(false);
							info.setErrorMsg("您尚未激活，请激活");
						}
					}
					...
		2）登录成功后显示用户名：
				header.html中异步获取登录的用户名称的逻辑：
					//查询用户信息
					$.get("findUserSerlet",{},function (data) {
					   //{uid:1,name:'李四'}
					   if(data){//如果对象存在，则转为true；否则转为false
						   var msg = "欢迎回来，"+data.name;
						   $("#span_username").html(msg);
					   }
				   });

	5）用户退出
		* 核心：判断session中是否有用户信息
					有：表示已经登录
					无：表示未登录
		* 做法：销毁session
					有三种办法：
						session过期了
						关闭服务器
						调用session的invalidate()方法

	6）BaseServlet的抽取
		目的：减少Servlet的个数，方便维护。
		做法：由一个请求对应一个Servlet的方式，改变为多个请求对应一个Servlet。要求：
				1）servlet的请求路径的定义
						/模块名称/*		: * 代表了方法名， user/findOne, 执行UserServlet中的findOne的方法
				2）必须编写一个BaseServlet，作用是重写HttpServlet中的service方法，实现方法的分发
						要求：BaseServlet只是一个工具类，自定义的Servlet需要继承BaseServlet
				3）要求自定义的Servlet中的方法的格式必须是：
						public void 方法名(HttpServletRequest request, HttpServletResponse response){
						
						}